# 文件操作

文件操作的知识其实用过很多次了，但是可能每次操作使用的方法都不太一样，我到现在都没彻底掌握如何去创建、读、写一个文件。

这里就是整理一下操作的方法。

## os.File

`os.File` 是 `os` 库中的一个结构体类型，代表一个打开的文件，是对操作系统底层文件描述符的封装。

可以把它理解为一个“文件句柄”或者“文件对象”。之后对文件的读、写、关闭都在其中。

## 文件 API 底层 - `OpenFile()`

文件中复杂的原因在于 API 提供的太多。比如说一会儿是 `os.Open()`，一会儿是 `os.OpenFile()`，一会儿是 `os.Create()`。实际上所有 API 的底层都是使用 `OpenFile()` 这个 API 来实现的。

```go
// os/file.go
func Open(name string) (*File, error) {
    return OpenFile(name, O_RDONLY, 0)
}

func Create(name string) (*File, error) {
    return OpenFile(name, O_WRONLY|O_CREATE|O_TRUNC, 0666)
}
```

`OpenFile()` 的定义：

```go
func OpenFile(name string, flag int, perm FileMode) (*File, error) {
    // ...
}
```

其中参数的定义：

| 参数   | 类型       | 说明                                              |
| ------ | ---------- | ------------------------------------------------- |
| `name` | `string`   | 文件路径                                          |
| `flag` | `int`      | 打开模式（读、写、追加），来自 `os` 包中的常量    |
| `perm` | `FileMode` | 文件权限（仅在创建文件时有效），如 `0644`、`0666` |

返回值是 `*File` 文件句柄类型和 `error` 类型。

常用的 `flag` 如下：

| 常量          | 含义                               |
| ------------- | ---------------------------------- |
| `os.O_RDONLY` | 只读模式                           |
| `os.O_WRONLY` | 只写模式                           |
| `os.O_RDWR`   | 可读可写                           |
| `os.O_CREATE` | 文件不存在则创建                   |
| `os.O_TRUNC`  | 打开时清空文件内容                 |
| `os.O_APPEND` | 追加模式，写入文件时从文件末尾开始 |

为了统一，之后我们打开文件的时候，都尽量使用 `OpenFile()` 函数，不再使用 `Open()`、`Create()` 之类的 API 了。

## 读文件

### 字符文件

使用 `os.OpenFile()` + `bufio.Scanner`：

```go
func main() {
	file, err := os.OpenFile("example.txt", os.O_RDONLY, 0)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		fmt.Println("文件内容: " + line)
	}
}
```

输出：

```go
[root@JiGeX files-demo]# go build . && ./files-demo 
文件内容: Hello, 世界!
文件内容: aaa
文件内容: asda
文件内容: zxcz
```

### 字节文件

使用 `os.ReadFile()`：

```go
func main() {
	data, err := os.ReadFile("example.txt")
	if err != nil {
		log.Fatal(err)
	}
	fmt.Println("字节长度:", len(data))
	fmt.Println("数据:\n", string(data))
}
```

输出：

```go
[root@JiGeX files-demo]# go build . && ./files-demo 
字节长度: 43
数据: Hello, 世界!
aaa
asda
zxcz
```

## 写文件

### 覆盖写

其实创建文件也属于写文件的范畴。如果要覆盖写一个文件，可以使用 `os.Create()` 创建新文件（原本就有的话，会覆盖原文件）。之后再通过 `bufio.NewWriter(file)` 定义出新的 `writer`，然后使用 `writer.WriteString()` 写文件。 

```go
func main() {
    // 覆盖写：
	file, err := os.OpenFile("log.txt", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
    defer writer.Flush()

	writer.WriteString("第一行内容\n")
	writer.WriteString("第二行内容\n")
	writer.Write([]byte("字节转过来的内容 \n"))
}
```

### 追加写

```go
func main() {
	file, err := os.OpenFile("log.txt", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
	if err != nil {
		log.Fatal(err)
	}
	defer file.Close()

	writer := bufio.NewWriter(file)
	defer writer.Flush()

	writer.WriteString("hello world1\n")
	writer.WriteString("hello world2\n")
	writer.Write([]byte("字节转过来的字符串"))
}
```

## 总结

读字符文件：

```go
os.OpenFile("example.txt", os.O_RDONLY, 0)
scanner := bufio.NewScanner(file)
for scanner.Scan() {
    line := scanner.Text()
    fmt.Println("文件内容: " + line)
}
```

读字节文件：

```go
data, err := os.ReadFile("example.txt")
```

覆盖写文件：

```go
file, err := os.OpenFile("log.txt", os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0666)
writer := bufio.NewWriter(file)
defer writer.Flush()
writer.WriteString("第一行内容\n")
```

追加写文件：

```go
file, err := os.OpenFile("log.txt", os.O_CREATE|os.O_WRONLY|os.O_APPEND, 0666)
writer := bufio.NewWriter(file)
defer writer.Flush()
writer.WriteString("第一行内容\n")
```







