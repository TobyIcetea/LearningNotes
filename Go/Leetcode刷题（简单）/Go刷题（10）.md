# Go刷题（10）

## 271. 上升下降字符串（1370）

给你一个字符串 `s` ，请你根据下面的算法重新构造字符串：

1. 从 `s` 中选出 **最小** 的字符，将它 **接在** 结果字符串的后面。
2. 从 `s` 剩余字符中选出比上一个添加字符更大的 **最小** 字符，将它 **接在** 结果字符串后面。
3. 重复步骤 2 ，直到你没法从 `s` 中选择字符。
4. 从 `s` 中选出 **最大** 的字符，将它 **接在** 结果字符串的后面。
5. 从 `s` 剩余字符中选出比上一个添加字符更小的 **最大** 字符，将它 **接在** 结果字符串后面。
6. 重复步骤 5 ，直到你没法从 `s` 中选择字符。
7. 重复步骤 1 到 6 ，直到 `s` 中所有字符都已经被选过。

在任何一步中，如果最小或者最大字符不止一个 ，你可以选择其中任意一个，并将其添加到结果字符串。

请你返回将 `s` 中字符重新排序后的 **结果字符串** 。

```go
func sortString(s string) string {
    count := make([]int, 26)
    for i := 0; i < len(s); i++ {
        count[s[i] - 'a']++
    }
    var builder strings.Builder

    resLen := 0
    for resLen != len(s) {
        for i := 0; i < 26; i++ {
            if count[i] != 0 {
                builder.WriteRune(rune(i + 'a'))
                count[i]--
                resLen++
            }
        }
        for i := 25; i >= 0; i-- {
            if count[i] != 0 {
                builder.WriteRune(rune(i + 'a'))
                count[i]--
                resLen++
            }
        }
    }

    return builder.String()
}
```

## 272. 生成每种字符都是奇数个的字符串（1374）

给你一个整数 `n`，请你返回一个含 *`n`* 个字符的字符串，其中每种字符在该字符串中都恰好出现 **奇数次** ***。***

返回的字符串必须只含小写英文字母。如果存在多个满足题目要求的字符串，则返回其中任意一个即可。

```go
func generateTheString(n int) string {
    char := 'a'

    var builder strings.Builder

    for n > 0 {
        if n >= 25 {
            // 加 25 个 char 元素
            for i := 0; i < 25; i++ {
                builder.WriteRune(char)
            }
            n -= 25
            char++
        } else {
            if n & 1 == 1 {
                for i := 0; i < n; i ++ {
                    builder.WriteRune(char)
                }
                n = 0
                char++
            } else {
                for i := 0; i < n - 1; i ++ {
                    builder.WriteRune(char)
                }
                n = 1
                char++
            }
        }
    }

    return builder.String()
}
```

## 273. 矩阵中的幸运数（1380）

给你一个 `m x n` 的矩阵，矩阵中的数字 **各不相同** 。请你按 **任意** 顺序返回矩阵中的所有幸运数。

**幸运数** 是指矩阵中满足同时下列两个条件的元素：

- 在同一行的所有元素中最小
- 在同一列的所有元素中最大

```go
func luckyNumbers(matrix [][]int) []int {
	m := len(matrix)
	n := len(matrix[0])

	minOfLines := make([]int, m)
	for i := 0; i < m; i++ {
		minIndex := 0
		for j := 0; j < n; j++ {
			if matrix[i][j] < matrix[i][minIndex] {
				minIndex = j
			}
		}
		minOfLines[i] = matrix[i][minIndex]
	}

    maxOfColumns := make([]int, n)
	for j := 0; j < n; j++ {
		maxIndex := 0
		for i := 0; i < m; i++ {
			if matrix[i][j] > matrix[maxIndex][j] {
				maxIndex = i
			}
		}
		maxOfColumns[j] = matrix[maxIndex][j]
	}

	res := make([]int, 0)
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if minOfLines[i] == maxOfColumns[j] {
				res = append(res, minOfLines[i])
			}
		}
	}

	return res
}
```

## 274. 两个数组间的距离值（1385）

给你两个整数数组 `arr1` ， `arr2` 和一个整数 `d` ，请你返回两个数组之间的 **距离值** 。

「**距离值**」 定义为符合此距离要求的元素数目：对于元素 `arr1[i]` ，不存在任何元素 `arr2[j]` 满足 `|arr1[i]-arr2[j]| <= d` 。

```go
func findTheDistanceValue(arr1 []int, arr2 []int, d int) int {
    res := 0

Outer:
    for _, num := range arr1 {
        upper := num + d
        lower := num - d
        for i := range arr2 {
            if arr2[i] >= lower && arr2[i] <= upper {
                continue Outer
            }
        }
        res++
    }

    return res
}
```

## 275. 按既定顺序创建目标数组（1389）

给你两个整数数组 `nums` 和 `index`。你需要按照以下规则创建目标数组：

- 目标数组 `target` 最初为空。
- 按从左到右的顺序依次读取 `nums[i]` 和 `index[i]`，在 `target` 数组中的下标 `index[i]` 处插入值 `nums[i]` 。
- 重复上一步，直到在 `nums` 和 `index` 中都没有要读取的元素。

请你返回目标数组。

题目保证数字插入位置总是存在。

```go
func createTargetArray(nums []int, index []int) []int {
	res := make([]int, 0, len(nums))
	for i, num := range nums {
		res = append(res[:index[i]], append([]int{num}, res[index[i]:]...)...)
	}
	return res
}
```

其实第一次写的代码是这样的：

```go
	for i, num := range nums {
        res = append(res[:index[i]], num, res[index[i]:]...)
	}
```

但是这样不对，因为语法过不去。Go 的 append 后面要么跟单个或多个元素，要么就跟切片展开，不能混用单个元素和切片展开。

第二次改成这样了：

```go
	for i, num := range nums {
		res = append(append(res[:index[i]], num), res[index[i]:]...)
	}
```

这样虽然语法对了，但是功能是不对的。比如当前的 res 是 `[0, 1, 2]`，现在我们要将 3 元素插入到 2 位置，那么此时会优先执行内部的 append，也就是 `append(res[:index[i]], num)`，得到 `res = [0, 1, 3]`之后再将 `index[i]` append 到后面，此时 `index[i] == 3`，所以最终操作的结果就变成了 `res = [0, 1, 3, 3]`，而不是我们想要的 `[0, 1, 3, 2]`。

最后使用的代码，先创建了只有 num 元素的切片，将后半部分元素加到这个切片的后面，然后将合成的切片追加到前半部分元素的后面。其中有一个小知识点，之后如果要在一个单个元素后面追加一个切片，可以先将这个元素转化成切片，之后就可以进行 append 操作了。

## 276. 找出数组中的幸运数（1394）

在整数数组中，如果一个整数的出现频次和它的数值大小相等，我们就称这个整数为「幸运数」。

给你一个整数数组 `arr`，请你从中找出并返回一个幸运数。

- 如果数组中存在多个幸运数，只需返回 **最大** 的那个。
- 如果数组中不含幸运数，则返回 **-1** 。

```go
func findLucky(arr []int) int {
    count := make([]int, 501)
    maxNum := -1
    for _, num := range arr {
        maxNum = max(maxNum, num)
        count[num]++
    }
    for i := maxNum; i >= 1; i-- {
        if count[i] == i {
            return i
        }
    }
    return -1
}
```

## 277. 统计最大组的数目（1399）

给你一个整数 `n` 。请你先求出从 `1` 到 `n` 的每个整数 10 进制表示下的数位和（每一位上的数字相加），然后把数位和相等的数字放到同一个组中。

请你统计每个组中的数字数目，并返回数字数目并列最多的组有多少个。

```go
func countLargestGroup(n int) int {
	// key: 数位加和是多少
	// value: 这样的数字又多少个
	sumOfDigitsToCount := make(map[int]int)
	maxCount := -1
	for i := 1; i <= n; i++ {
		num := i
		sum := 0
		for num != 0 {
			sum += num % 10
			num /= 10
		}
		sumOfDigitsToCount[sum]++
		maxCount = max(maxCount, sumOfDigitsToCount[sum])
	}

	res := 0

	for _, v := range sumOfDigitsToCount {
		if v == maxCount {
			res++
		}
	}

	return res
}
```

## 278. 非递增顺序的最小子序列（1403）

给你一个数组 `nums`，请你从中抽取一个子序列，满足该子序列的元素之和 **严格** 大于未包含在该子序列中的各元素之和。

如果存在多个解决方案，只需返回 **长度最小** 的子序列。如果仍然有多个解决方案，则返回 **元素之和最大** 的子序列。

与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。

**注意**，题目数据保证满足所有约束条件的解决方案是 **唯一** 的。同时，返回的答案应当按 **非递增顺序** 排列。

```go
func minSubsequence(nums []int) []int {
    sort.Slice(nums, func(i, j int) bool {
        return nums[i] > nums[j]
    })
    sum := 0
    for _, num := range nums {
        sum += num
    }
    half := sum / 2

    curSum := 0
    for i := range nums {
        curSum += nums[i]
        if curSum > half {
            return nums[:i + 1]
        }
    }
    return []int{}
}
```

## 279. 数组中的字符串匹配（1408）

给你一个字符串数组 `words` ，数组中的每个字符串都可以看作是一个单词。请你按 **任意** 顺序返回 `words` 中是其他单词的 子字符串 的所有单词。

```go
func stringMatching(words []string) []string {
	res := make([]string, 0)
	for i := 0; i < len(words); i++ {
		for j := 0; j < len(words); j++ {
			// 看 i 是不是 j 的字串
			if i == j {
				continue
			}
			if strings.Contains(words[j], words[i]) {
				res = append(res, words[i])
				break
			}
		}
	}
	return res
}
```

## 280. 逐步求和得到正数的最小值（1413）

给你一个整数数组 `nums` 。你可以选定任意的 **正数** startValue 作为初始值。

你需要从左到右遍历 `nums` 数组，并将 startValue 依次累加上 `nums` 数组中的值。

请你在确保累加和始终大于等于 1 的前提下，选出一个最小的 **正数** 作为 startValue 。

```go
func minStartValue(nums []int) int {
    minPrefixSum := 0
    sum := 0
    for _, num := range nums {
        sum += num
        minPrefixSum = min(minPrefixSum, sum)
    }

    if minPrefixSum < 1 {
        return -minPrefixSum + 1
    } else {
        return 1
    }
}
```

## 281. 重新格式化字符串（1417）

给你一个混合了数字和字母的字符串 `s`，其中的字母均为小写英文字母。

请你将该字符串重新格式化，使得任意两个相邻字符的类型都不同。也就是说，字母后面应该跟着数字，而数字后面应该跟着字母。

请你返回 **重新格式化后** 的字符串；如果无法按要求重新格式化，则返回一个 **空字符串** 。

```go
func reformat(s string) string {
	if len(s) == 1 {
		return s
	}

    var chars []byte
    var nums []byte
	for i := 0; i < len(s); i++ {
		if s[i] >= '0' && s[i] <= '9' {
            nums = append(nums, s[i])
		} else {
            chars = append(chars, s[i])
		}
	}

	Abs := func(x int) int {
		if x < 0 {
			return -x
		} else {
			return x
		}
	}

	if Abs(len(chars)-len(nums)) > 1 {
		return ""
	}

    mergeStrToStr := func(more []byte, less []byte) string {
        builder := strings.Builder{}

        indexOfMore := 0
        indexOfLess := 0
        for i := 0; i < len(less); i++ {
            builder.WriteByte(more[indexOfMore])
            builder.WriteByte(less[indexOfLess])
            indexOfMore++
            indexOfLess++
        }
        if indexOfMore < len(more) {
            builder.WriteByte(more[indexOfMore])
        }

        return builder.String()
    }

    if len(chars) >= len(nums) {
        return mergeStrToStr(chars, nums)
    } else {
        return mergeStrToStr(nums, chars)
    }
}
```

如果遇到这种，对于 less 和 more 两个子串在一块儿，如果要处理的时候，要分为 less 和 more 两块逻辑上相同的代码。使用函数可以避免代码的繁琐。

## 282. 拥有最多糖果的孩子（1431）

有 `n` 个有糖果的孩子。给你一个数组 `candies`，其中 `candies[i]` 代表第 `i` 个孩子拥有的糖果数目，和一个整数 `extraCandies` 表示你所有的额外糖果的数量。

返回一个长度为 `n` 的布尔数组 `result`，如果把所有的 `extraCandies` 给第 `i` 个孩子之后，他会拥有所有孩子中 **最多** 的糖果，那么 `result[i]` 为 `true`，否则为 `false`。

注意，允许有多个孩子同时拥有 **最多** 的糖果数目。

```go
func kidsWithCandies(candies []int, extraCandies int) []bool {
    maxNum := 0
    for _, num := range candies {
        maxNum = max(maxNum, num)
    }
    target := maxNum - extraCandies

    res := make([]bool, len(candies))
    for i := range candies {
        if candies[i] >= target {
            res[i] = true
        }
    }

    return res
}
```

## 283. 旅行终点站（1436）

给你一份旅游线路图，该线路图中的旅行线路用数组 `paths` 表示，其中 `paths[i] = [cityAi, cityBi]` 表示该线路将会从 `cityAi` 直接前往 `cityBi` 。请你找出这次旅行的终点站，即没有任何可以通往其他城市的线路的城市*。*

题目数据保证线路图会形成一条不存在循环的线路，因此恰有一个旅行终点站。

```go
func destCity(paths [][]string) string {
    isSourceCity := make(map[string]bool)
    for _, path := range paths {
        isSourceCity[path[0]] = true
        if _, ok := isSourceCity[path[1]]; !ok {
            isSourceCity[path[1]] = false
        }
    }

    for city, isSource := range isSourceCity {
        if !isSource {
            return city
        }
    }

    return ""
}
```

## 284. 是否所有 1 都至少相隔 k 个元素（1437）

给你一个由若干 `0` 和 `1` 组成的数组 `nums` 以及整数 `k`。如果所有 `1` 都至少相隔 `k` 个元素，则返回 true ；否则，返回 `false` 。

```go
func kLengthApart(nums []int, k int) bool {
    count := 0  // 步数计数
    index := 0
    for index < len(nums) && nums[index] != 1 {
        index++
    }
    index += 1
    for index < len(nums) {
        if nums[index] == 1 {
            if count < k {
                return false
            }
            count = 0
        } else {
            count++
        }

        index++
    }

    return true
}
```













待做题目：

```bash
1446. 连续字符
889
60.3%
简单
1450. 在既定时间做作业的学生人数
814
83.8%
简单
1455. 检查单词是否为句中其他单词的前缀
762
64.3%
简单
1460. 通过翻转子数组使两个数组相等
804
77.2%
简单
1464. 数组中两元素的最大乘积
974
78.1%
简单
1470. 重新排列数组
1341
83.5%
简单
1475. 商品折扣后的最终价格
1027
75.0%
简单
1480. 一维数组的动态和
2792
76.5%
简单
1486. 数组异或操作
930
83.4%
简单
1491. 去掉最低工资和最高工资后的工资平均值
907
64.6%
简单
1496. 判断路径是否相交
292
54.7%
简单
1502. 判断能否形成等差数列
773
67.9%
简单
1507. 转变日期格式
238
60.7%
简单
1512. 好数对的数目
1350
83.3%
简单
1518. 换水问题
984
69.8%
简单
1523. 在区间范围内统计奇数数目
924
50.7%
简单
1528. 重新排列字符串
534
79.2%
简单
1534. 统计好三元组
466
76.1%
简单
1539. 第 k 个缺失的正整数
680
55.0%
简单
1544. 整理字符串
522
58.3%
简单
1550. 存在连续三个奇数的数组
455
65.7%
简单
1556. 千位分隔数
342
56.9%
简单
1560. 圆形赛道上经过次数最多的扇区
151
58.5%
简单
1566. 重复至少 K 次且长度为 M 的模式
219
45.2%
简单
1572. 矩阵对角线元素的和
924
83.0%
简单
1576. 替换所有的问号
694
50.5%
简单
1582. 二进制矩阵中的特殊位置
499
69.2%
简单
1588. 所有奇数长度子数组的和
1063
82.6%
简单
1592. 重新排列单词间的空格
605
46.7%
简单
1598. 文件夹操作日志搜集器
577
69.7%
简单
1603. 设计停车系统
632
83.4%
简单
1608. 特殊数组的特征值
856
61.7%
简单
1614. 括号的最大嵌套深度
941
81.6%
简单
1619. 删除某些元素后的数组均值
486
72.3%
简单
1624. 两个相同字符之间的最长子字符串
730
64.6%
简单
1629. 按键持续时间最长的键
469
56.0%
简单
1636. 按照频率将数组升序排序
657
75.0%
简单
1637. 两点之间不包含任何点的最宽垂直区域
304
84.1%
简单
1640. 能否连接形成数组
693
61.2%
简单
1646. 获取生成数组中的最大值
546
51.4%
简单
1652. 拆炸弹
891
71.4%
简单
1656. 设计有序流
436
85.6%
简单

```

