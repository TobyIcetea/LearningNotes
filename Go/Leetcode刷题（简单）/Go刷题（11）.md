# Go刷题（11）

## 301. 整理字符串（1544）

给你一个由大小写英文字母组成的字符串 `s` 。

一个整理好的字符串中，两个相邻字符 `s[i]` 和 `s[i+1]`，其中 `0<= i <= s.length-2` ，要满足如下条件:

- 若 `s[i]` 是小写字符，则 `s[i+1]` 不可以是相同的大写字符。
- 若 `s[i]` 是大写字符，则 `s[i+1]` 不可以是相同的小写字符。

请你将字符串整理好，每次你都可以从字符串中选出满足上述条件的 **两个相邻** 字符并删除，直到字符串整理好为止。

请返回整理好的 **字符串** 。题目保证在给出的约束条件下，测试样例对应的答案是唯一的。

**注意：**空字符串也属于整理好的字符串，尽管其中没有任何字符。

```go
func makeGood(s string) string {

    stk := make([]byte, 0)
    for i := 0; i < len(s); i++ {
        if len(stk) == 0 || stk[len(stk)-1] != s[i] + 32 && stk[len(stk)-1] != s[i] - 32 {
            stk = append(stk, s[i])
        } else {
            stk = stk[:len(stk)-1]
        }
    }

    return string(stk)
}
```

如果需要频繁从中间删除一个数组 / 字符串中的元素，优先考虑**栈**。

## 302. 存在连续三个奇数的数组（1550）

给你一个整数数组 `arr`，请你判断数组中是否存在连续三个元素都是奇数的情况：如果存在，请返回 `true` ；否则，返回 `false` 。

```go
func threeConsecutiveOdds(arr []int) bool {
    for i := 2; i < len(arr); i++ {
        if arr[i] & 1 == 1 && arr[i - 1] & 1 == 1 && arr[i - 2] & 1 == 1 {
            return true
        }
    }
    return false
}
```

## 303. 千位分隔数（1556）

给你一个整数 `n`，请你每隔三位添加点（即 "." 符号）作为千位分隔符，并将结果以字符串格式返回。

```go
func thousandSeparator(n int) string {
    if n == 0 {
        return "0"
    }

    count := 0
    var builder strings.Builder

    for n != 0 {
        builder.WriteByte(byte(n%10 + '0'))
        n /= 10
        count++
        if count % 3 == 0 {
            builder.WriteByte('.')
        }
    }
    bytes := []byte(builder.String())
    if len(bytes) > 0 && bytes[len(bytes) - 1] == '.' {
        bytes = bytes[:len(bytes) - 1]
    }

    left := 0
    right := len(bytes) - 1
    for left <= right {
        bytes[left], bytes[right] = bytes[right], bytes[left]
        left++
        right--
    }

    return string(bytes)
}
```

## 304. 圆形赛道上经过次数最多的扇区（1560）

给你一个整数 `n` 和一个整数数组 `rounds` 。有一条圆形赛道由 `n` 个扇区组成，扇区编号从 `1` 到 `n` 。现将在这条赛道上举办一场马拉松比赛，该马拉松全程由 `m` 个阶段组成。其中，第 `i` 个阶段将会从扇区 `rounds[i - 1]` 开始，到扇区 `rounds[i]` 结束。举例来说，第 `1` 阶段从 `rounds[0]` 开始，到 `rounds[1]` 结束。

请你以数组形式返回经过次数最多的那几个扇区，按扇区编号 **升序** 排列。

注意，赛道按扇区编号升序逆时针形成一个圆（请参见第一个示例）。

```go
func mostVisited(n int, rounds []int) []int {
	visits := make([]int, n+1)
	visits[rounds[0]] = 1
	for i := 1; i < len(rounds); i++ {
		// 起初的地方不加，结尾的地方加上
		if rounds[i] <= rounds[i-1] {
			// 从 rounds[i-1] + 1 的地方一直加到 n
			// 再从 1 的地方一直加到 rounds[i]
			for j := rounds[i-1] + 1; j <= n; j++ {
				visits[j]++
			}
			for j := 1; j <= rounds[i]; j++ {
				visits[j]++
			}
		} else {
			// 从 rounds[i-1]+1 一直加到 rounds[i]
			for j := rounds[i-1] + 1; j <= rounds[i]; j++ {
				visits[j]++
			}
		}
	}

	maxValue := 0
	for i := 1; i <= n; i++ {
		maxValue = max(maxValue, visits[i])
	}

	res := make([]int, 0)
	for i := 1; i <= n; i++ {
		if visits[i] == maxValue {
			res = append(res, i)
		}
	}

	return res
}
```

写这个题目的时候，真的觉得自己的思路就是很模糊的。后来发现这个题更简单的解法：我们只需要关注跑道的起点和终点就行了：

```go
func mostVisited(n int, rounds []int) []int {
	// 只需要看起点和终点就行
	begin := rounds[0]
	end := rounds[len(rounds)-1]

	res := make([]int, 0)
	if begin < end {
		for i := begin; i <= end; i++ {
			res = append(res, i)
		}
	} else if begin == end {
		res = append(res, begin)
	} else {
		// 从 1 加到 end
		// 从 begin 加到最后
		for i := 1; i <= end; i++ {
			res = append(res, i)
		}
		for i := begin; i <= n; i++ {
			res = append(res, i)
		}
	}

	return res
}
```

## 305. 重复至少 K 次且长度为 M 的模式（1566）

给你一个正整数数组 `arr`，请你找出一个长度为 `m` 且在数组中至少重复 `k` 次的模式。

**模式** 是由一个或多个值组成的子数组（连续的子序列），**连续** 重复多次但 **不重叠** 。 模式由其长度和重复次数定义。

如果数组中存在至少重复 `k` 次且长度为 `m` 的模式，则返回 `true` ，否则返回 `false` 。

```go
func containsPattern(arr []int, m int, k int) bool {
Outer:
	for i := 0; i+m-1 < len(arr) && len(arr)-i >= m*k; i++ {
		// i 是起始元素
		pattern := arr[i : i+m]
		index := 0
		// 保证后面出现 k 个长度同样为 m 的通常的串
		for j := i + m; j < i+m*k; j++ {
			if arr[j] != pattern[index] {
				continue Outer
			}
			index = (index + 1) % len(pattern)
		}
		return true
	}
	return false
}
```

## 306. 替换所有的问号（1576）

给你一个仅包含小写英文字母和 `'?'` 字符的字符串 `s`，请你将所有的 `'?'` 转换为若干小写字母，使最终的字符串不包含任何 **连续重复** 的字符。

注意：你 **不能** 修改非 `'?'` 字符。

题目测试用例保证 **除** `'?'` 字符 **之外**，不存在连续重复的字符。

在完成所有转换（可能无需转换）后返回最终的字符串。如果有多个解决方案，请返回其中任何一个。可以证明，在给定的约束条件下，答案总是存在的。

```go
func modifyString(s string) string {
    bytes := []byte(s)
    for i := 0; i < len(bytes); i++ {
        if bytes[i] == '?' {
            var leftChar byte
            var rightChar byte
            if i > 0 {
                leftChar = bytes[i-1]
            }
            if i < len(bytes)-1 {
                rightChar = bytes[i+1]
            }
            // 从小写字母中找一个不等于 leftChar 也不等于 rightChar 的
            for j := byte('a'); j <= byte('z'); j++ {
                if j != leftChar && j != rightChar {
                    bytes[i] = j
                    break
                }
            }
        }
    }

    return string(bytes)
}
```

## 307. 二进制矩阵中的特殊位置（1582）

给定一个 `m x n` 的二进制矩阵 `mat`，返回矩阵 `mat` 中特殊位置的数量。

如果位置 `(i, j)` 满足 `mat[i][j] == 1` 并且行 `i` 与列 `j` 中的所有其他元素都是 `0`（行和列的下标从 **0** 开始计数），那么它被称为 **特殊** 位置。

```go
func numSpecial(mat [][]int) int {
	m := len(mat)
	n := len(mat[0])
	countRows := make([]int, m)
	countCols := make([]int, n)

	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if mat[i][j] == 1 {
				countRows[i]++
				countCols[j]++
			}
		}
	}

	res := 0
	for i := 0; i < m; i++ {
		for j := 0; j < n; j++ {
			if mat[i][j] == 1 && countRows[i] == 1 && countCols[j] == 1 {
				res++
			}
		}
	}

	return res
}
```

## 308. 所有奇数长度子数组的和（1588）

给你一个正整数数组 `arr` ，请你计算所有可能的奇数长度子数组的和。

**子数组** 定义为原数组中的一个连续子序列。

请你返回 `arr` 中 **所有奇数长度子数组的和** 。

```go
func sumOddLengthSubarrays(arr []int) int {
	// 前缀和
	// 之后 arr[i] 就是前 i 个元素的和
	for i := 1; i < len(arr); i++ {
		arr[i] += arr[i - 1]
	}

	res := 0

	for begin := 0; begin < len(arr); begin++ {
		for end := begin; end < len(arr); end += 2 {
			// 算 [begin, end] 之间的元素和
			// 其实就是算 arr[end] - arr[begin - 1]
			if begin == 0 {
				res += arr[end]
			} else {
				res += arr[end] - arr[begin - 1]
			}
		}
	}

	return res
}
```

## 309. 重新排列单词间的空格（1592）

给你一个字符串 `text` ，该字符串由若干被空格包围的单词组成。每个单词由一个或者多个小写英文字母组成，并且两个单词之间至少存在一个空格。题目测试用例保证 `text` **至少包含一个单词** 。

请你重新排列空格，使每对相邻单词之间的空格数目都 **相等** ，并尽可能 **最大化** 该数目。如果不能重新平均分配所有空格，请 **将多余的空格放置在字符串末尾** ，这也意味着返回的字符串应当与原 `text` 字符串的长度相等。

返回 **重新排列空格后的字符串** 。

```go
func reorderSpaces(text string) string {
    words := strings.Fields(text)
    countOfSpace := 0
    for i := 0; i < len(text); i++ {
        if text[i] == ' ' {
            countOfSpace++
        }
    }

    if len(words) == 1 {
        return words[0] + strings.Repeat(" ", countOfSpace)
    }

    spacesBetweenWords := countOfSpace / (len(words) - 1)
    spacesLast := countOfSpace % (len(words) - 1)

    builder := strings.Builder{}

    for i, word := range words {
        builder.WriteString(word)
        if i != len(words)-1 {
            // 写 spacesBetweenWords 个空格
            for j := 0; j < spacesBetweenWords; j++ {
                builder.WriteByte(' ')
            }
        } else {
            // 写 spacesLast 个空格
            for j := 0; j < spacesLast; j++ {
                builder.WriteByte(' ')
            }
        }
    }

    return builder.String()
}
```

## 310. 文件夹操作日志搜集器（1598）

每当用户执行变更文件夹操作时，LeetCode 文件系统都会保存一条日志记录。

下面给出对变更操作的说明：

- `"../"` ：移动到当前文件夹的父文件夹。如果已经在主文件夹下，则 **继续停留在当前文件夹** 。
- `"./"` ：继续停留在当前文件夹**。**
- `"x/"` ：移动到名为 `x` 的子文件夹中。题目数据 **保证总是存在文件夹 `x`** 。

给你一个字符串列表 `logs` ，其中 `logs[i]` 是用户在 `ith` 步执行的操作。

文件系统启动时位于主文件夹，然后执行 `logs` 中的操作。

执行完所有变更文件夹操作后，请你找出 **返回主文件夹所需的最小步数** 。

```go
func minOperations(logs []string) int {
    // res 表示现在的目录深度和根目录的距离
    res := 0

    for _, l := range logs {
        if strings.HasPrefix(l, "../") {
            if res > 0 {
                res--
            }
        } else if !strings.HasPrefix(l, ".") {
            res++
        }
        // 最后一种情况是 './'  这种什么都不用做
    }

    return res
}
```









待做题目：

```bash
1603. 设计停车系统
632
83.4%
简单
1608. 特殊数组的特征值
856
61.7%
简单
1614. 括号的最大嵌套深度
941
81.6%
简单
1619. 删除某些元素后的数组均值
486
72.3%
简单
1624. 两个相同字符之间的最长子字符串
730
64.6%
简单
1629. 按键持续时间最长的键
469
56.0%
简单
1636. 按照频率将数组升序排序
657
75.0%
简单
1637. 两点之间不包含任何点的最宽垂直区域
304
84.1%
简单
1640. 能否连接形成数组
693
61.2%
简单
1646. 获取生成数组中的最大值
546
51.4%
简单
1652. 拆炸弹
891
71.4%
简单
1656. 设计有序流
436
85.6%
简单

```

